Блочные элементы [1/23]

Элементы HTML страницы обычно делятся на блочные и строчные.
Блочные элементы можно представлять как прямоугольные области на странице.
Они имеют следующие особенности:
  1. До и после блочного элемента существует перенос строки.
  2. Блочным элементам можно задавать ширину, высоту, внутренние и внешние
     отступы.
  3. Занимают всё доступное пространство по горизонтали.
К блочным элементам относятся такие теги как: <p>, <h1>, <h2>, <ul> и так далее.
Еще один важный блочный тег — это тег <div>, который обозначает просто «блок»
или «прямоугольный контейнер».
Этот тег чаще всего используется для создания сеток

Строчные элементы [2/23]

Строчные элементы располагаются друг за другом в одной строке, при необходимости
строка переносится.
Особенности строчных элементов:
  1. До и после строчного элемента отсутствуют переносы строки.
  2. Ширина и высота строчного элемента зависит только от его содержания,
     задать размеры с помощью CSS нельзя.
  3. Можно задавать только горизонтальные отступы.
К строчным элементам относятся такие теги как: <a>, <strong>, <em>, <span> и
так далее. Строчные элементы предназначены для оформления текста на уровне
небольших фраз и отдельных слов. Блочные же элементы предназначены для разметки
крупных блоков текста (заголовки, абзацы, списки) и создания сетки.

Ширина и высота [3/23]

Ширина и высота элементов задаются с помощью свойств width и height соответственно.
По умолчанию блочные элементы занимают всю доступную ширину, которая равна
ширине родительского контейнера или окна браузера.
Высота по умолчанию блочных элементов зависит от их содержимого. Если задать
блочному элементу ширину и высоту так, что содержимое элемента не будет в него
помещаться, то оно как бы «выпадет» из него.
Строчные элементы не реагируют на задание ширины и высоты в CSS.
Задать ширину блоку можно, например, так:
.selector {
    width: 100px;
    height: 100px;
}
Вернуть значения по умолчанию можно с помощью специального значения auto:
.selector {
    width: auto;
    height: auto;
}

Внутренние отступы, свойство padding [4/23]

Свойство padding задает внутренние отступы элемента — отступы от внешней
границы элемента до его содержания. Эти отступы еще иногда называют полями.
Существует несколько способов записи свойства padding:
  padding: 10px;                    //Одинаковые отступы со всех сторон
  padding: 5px 10px;                //Отступы сверху и снизу 5px, справа и
                                      слева 10px
  padding: 5px 10px 15px;           //Отступ сверху 5px, слева и справа 10px,
                                      снизу 15px
  padding: 5px 10px 15px 20px;      //Разные отступы со всех сторон, в порядке
                                      верхний, правый, нижний, левый
Также можно задавать отступы для разных сторон с помощью свойств padding-left,
padding-right, padding-top, padding-bottom.
Для строчных элементов лучше не задавать вертикальных отступов, т.к. они ведут
себя непредсказуемо.

Внешние отступы, свойство margin [5/23]

Свойство margin задает внешние отступы элемента — отступы от внешней границы
элемента до границ родительского элемента или до соседних элементов.

Способы записи свойства margin аналогичны свойству padding:
  margin: 10px;                     //Одинаковые отступы со всех сторон
  margin: 5px 10px;                 //Сверху и снизу 5px, справа и слева 10px
  margin: 5px 10px 15px;            //Сверху 5px, слева и справа 10px, снизу 15px
  margin: 5px 10px 15px 20px;       //Верхний, правый, нижний, левый отступы соответственно
Можно задавать отступы для разных сторон с помощью свойств margin-left,
margin-right, margin-top, margin-bottom.
Строчные элементы реагируют только на горизонтальные отступы.

Рамки [6/23]

Рамка задаётся с помощью свойства border, которое состоит из трёх компонентов:
  ширина рамки
  стиль рамки
  цвет
Например:
selector{                   //красную сплошную рамку толщиной 5px.
    border: 5px solid red;
}
Задавать рамку можно одним свойством border, а можно и с помощью
отдельных свойств border-width, border-style, border-color.
Например:
selector{                  //красную сплошную рамку толщиной 5px.
    border-width: 5px;
    border-style: solid;
    border-color: red;
}
Несколько самых распространенных стилей рамок:
  solid — сплошная;
  dashed — пунктирная;
  dotted — точками.
Рамку можно задавать и строчным, и блочным элементам.

Стандартная блочная модель [7/23]

Стандартная блочная модель отвечает на основной вопрос:
  Сколько же в итоге места будет занимать элемент?
Ответ следующий:
  Область, занимаемая блочным элементом, складывается из его ширины и высоты
  содержания, внутренних и внешних отступов, ширины рамок.
Для строчных элементов есть свои особенности.

«Схлопывание» внешних отступов [9/23]

Вертикальный отступ между двумя соседними элементами равен максимальному отступу
между ними. Если отступ одного элемента равен 20px, а второго 40px, то отступ
между ними будет 40px.
Этот эффект называется эффектом «схлопывания» внешних отступов или
«схлопывания» маргинов.
Горизонтальные отступы между элементами просто складываются.
Например, горизонтальный отступ между двумя элементами с отступами 30px будет
равен 60px.

«Выпадание» внешних отступов [10/23]

«Выпадание» — это еще один эффект, связанный с вертикальными внешними отступами.
Если внутри родительского блока расположить блок и задать ему отступ сверху,
то внутренний блок прижмется к верхнему краю родительского,
а у родительского элемента появится отступ сверху.
Т.е. верхний отступ внутреннего элемента «выпадает» из родительского элемента.
Если у родительского элемента тоже был задан внешний отступ,
то выберется максимальный отступ между собственным и «выпавшим» .
Чтобы избавиться от эффекта выпадания, можно задать родительскому элементу
внутренний отступ (паддинг) сверху или добавить рамку сверху.
Внешние и внутренние отступы всегда складываются.

Как отцентровать элемент? [11/23]

Чтобы отцентровать блочный элемент, нужно выполнить следующие действия:
  Задать элементу ширину, которая меньше ширины родительского контейнера.
  Задать для внешних отступов справа и слева значение auto.
selector {
    width: 100px;
    margin-left: auto;
    margin-right: auto;
}

Блочная модель и строчные элементы [12/23]

Еще раз акцентируем внимание на особенности поведения строчных элементов в
блочной модели:
  1. Не реагируют на CSS-свойства width и height.
  2. Частично реагируют на margin, воспринимая только горизонтальные отступы.
  3. Частично реагируют на padding, воспринимая только горизонтальные отступы.
  4. При задании вертикальных padding визуально увеличиваются,
     но без увеличения занимаемого места (не отталкивают другие элементы).
  5. Воспринимают рамки. Аналогично padding рамки сверху и снизу не увеличивают
     занимаемое элементом место.


Ширина 100% и ширина по умолчанию [13/23]

CSS-свойство width задаёт не общую ширину блока, а только ширину содержания.
Общая ширина блока затем складывается из трёх компонентов:
	1. ширины содержания
	2. внутренних отступов
	3. ширины рамок слева и справа.
Поведение элемента может зависеть от того, как именно вы зададите его ширину.
-----
Первый вариант.
Вариант по умолчанию, когда ширина не задается, соответствует значению width:auto;.
В этом случае блок занимает всю ширину родительского блока.
Если у блока есть внутренние отступы или рамки, то его ширина содержания
автоматически уменьшается, а общая ширина остается равной ширине родителя.
-----
Второй вариант.
Когда ширина блока задана явно, например, width:100%;.
В этом случае ширина содержания блока равна ширине родительского блока.
Если блоку добавить внутренние отступы и рамки, то его общая ширина становится
больше ширины родителя.

Проблемы обычной блочной модели [14/23]

В чём проблема описанного механизма расчета ширины?.
Ведь можно просто не задавать ширину, используя auto,
либо просто подбирать размеры блоков и отступов как на макете.
Проблемы начинаются, когда сетка резиновая и элементы в ней должны тянуться.
Самый простой пример: форма, в которой поля должны занимать всю ширину
контейнера, но при этом иметь фиксированные внутренние отступы, чтобы текст не
прилипал к краям. Для такой формы можно задать такие стили:
input[type="text"] {
    width: 100%;
    padding: 0 10px;
}
Ширина 100% заставит поля быть такой же ширины, как родительский блок, а паддинг
добавит отступы.
Но, как вы уже догадались, за счет отступов поле станет шире своего контейнера.
/*
   Ширина полей ввода определяется значением атрибута size.
   Ширина width: auto для полей ввода рассчитывается из значения size по
   умолчанию и не растягивает поля на всю ширину контейнера.
*/

Изменяем блочную модель, свойство box-sizing [15/23]

Проблему с шириной тянущихся полей решить сложно.
Идеальным вариантом было бы изменение алгоритма расчета ширины элемента,
чтобы свойство width задавало не ширину содержания, а общую ширину.
К счастью, такая возможность была добавлена в CSS3 с помощью свойства box-sizing,
которое уже поддерживается большинством современных браузеров.
Это свойство имеет два значения:
	content-box — значение по умолчанию, соответствует стандартной блочной модели.
	border-box —  ширина начинает включать поля и границы, но не отступы (margins)

Управление типом элемента, свойство display [17/23]

Тип элемента не является чем-то вечным и неизменным, его можно изменять с помощью CSS.
За это отвечает свойство display.
С его помощью, например, можно сделать абзацы и заголовки строчными, а спаны и
стронги блочными элементами.
  display: inline  //строчный
  display: block   //блочный элемент
  display: inline-block
Иногда возникает необходимость расположить в ряд несколько элементов с заданными
размерами. Строчные элементы для этого не подходят, т.к. не воспринимают размеры.
Блочные элементы тоже не подходят, т.к. до и после них существует перенос строки.
Конечно, блочные элементы можно приспособить для такой задачи, используя
дополнительные свойства. Но более простой способ — использовать блочно-строчные
элементы. В HTML нет тегов, которые по умолчанию вели бы себя как
блочно-строчные, но любой элемент можно переключить в данный режим,
задав ему свойство display со значением inline-block.

Особенности блочно-строчных элементов:
	a) им можно задавать размеры, рамки и отступы, как и блочным элементам;
	б) их ширина по умолчанию зависит от содержания, а не растягивается на всю
     ширину контейнера;
  в) они не порождают принудительных переносов строк, поэтому могут
     располагаться на одной строке, пока мещаются в родительский контейнер;
	г) элементы в одной строке выравниваются вертикально подобно строчным элементам.

display: table [19/23]

Дальнейшие несколько заданий будут посвящены табличным типам элементов.
Табличные сетки были очень популярны на заре веба.
Действительно, у табличных сеток есть преимущества, которые очень сложно
получить с помощью блоков. Например, столбцы одинаковой высоты. Однако,
семантически таблицы не предназначены для разметки сеток и постепенно от них
отказались. Но память об их удобстве жила.
Позднее было разработано семейство значений свойства display, которое позволяет
задать табличное поведение любым элементам.
Первое значение — display:table задает элементу тип таблица.
Особенности табличных элементов:
	а) можно задавать ширину, высоту, рамки, отступы;
	б) по умолчанию ширина зависит от содержания;
	в) переносы строки до и после элемента.
Табличные элементы похожи на блочные за исключением ширины по умолчанию.

display: table-row [20/23]

Строим таблицу на дивах с помощью новых значений свойства display.
Любая таблица содержит элементы строка таблицы, внутри которых должны
содержаться элементы ячейка таблицы. Соответствие тегов таблицы значениям
display:
	<table> — display:table;
	<tr> — display:table-row;
	<td> — display:table-cell;
Строка — необычный элемент. Она является контейнером для ячеек и практически
не имеет собственного отображения. Для нее можно только задавать цвет фона.

display: table-cell [21/23]

С помощью значения table-cell свойства display можно задать элементу тип ячейка
таблицы. Конечно, лучше чтобы элементы-ячейки находились внутри элементов-строк,
которые находятся внутри элементов-таблиц. Можно просто задать элементу тип
ячейка таблицы, не добавляя вокруг него дополнительных элементов-строк и таблиц.
В этом случае браузер создаст дополнительные анонимные элементы строки и таблицы.
Неудобство заключается в том, что вы не сможете ими управлять.
К таблицам, созданным с помощью CSS, можно применять те же свойства, что и к
обычным таблицам.
Например, задавать отступы между ячейками или режим схлопывания границ.

display: none [22/23]

Значение none свойства display используется очень часто.
С его помощью можно скрыть элемент, как будто его и не было.
Скрытый элемент не отображается и не занимает места на странице.
Данное свойство применяется при создании выпадающих меню, динамических галерей,
переключающихся вкладок и много где еще.
Есть еще одно CSS-свойство, которое используется для сокрытия элементов.
Это свойство visibility со значением hidden.
Оно «прячет» элемент — он становится невидимым, но занимает место на странице.


Сетки [1/1]

Сетка — это взаимное расположение крупных блоков сайта.
У ВКонтакте простая сетка, которая состоит из верхней части, или «хедера»,
под которой располагаются две колонки, а в самом низу расположен «футер» или
нижняя часть сайта. Вот так схематично можно представить сетку ВКонтакте:

-------------------------------------
 хедер
-------------------------------------
 левая колонка | правая колонка
 меню          | основное содержание
-------------------------------------
 футер
-------------------------------------
У HTML Academy на разных страницах используются разные сетки.
Например, на главной странице есть двухколончатый хедер, под ним содержание
страницы в три колонки, затем нижнее меню и двухколончатый футер.

Существует несколько способов управлять потоком и строить сетки:
  флоаты;
  инлайн-блоки;
  табличная вёрстка;
  флексбоксы.
Табличная вёрстка — самый простой для понимания способ построения сеток.
Но он считается устаревшим и использовать его не рекомендуется.
В будущем можно будет использовать для такой вёрстки не таблицы,
а элементы с display: table, display: table-row и display: table-cell.
Флексбоксы — это новая и очень мощная технология для построения сеток.
К сожалению, её поддержка браузерами ещё достаточно слабая.

Флоаты [8/32]

Изначально float было предназначено для того, чтобы включать обтекание элементов
текстом. Наподобие того, как в более старой версии HTML текст обтекал
изображения c атрибутами align="left" или align="right".
То есть, можно сказать, что float — это свойство, включающее режим обтекания.
Но, как часто бывает, судьба уготовила ему совсем другую роль.
Свойство float имеет следующие значения:
  left —  прижимает элемент к левому краю родителя, другие элементы обтекают
          его справа;
  right — прижимает элемент к правому краю родителя, другие элементы обтекают
          его слева;
  none —  отключает режим обтекания и возвращает элементу нормальное поведение.
Обратите внимание, что зафлоатить элемент по центру нельзя.

Как и позиционирование, float используется для того, чтобы двигать боксы.
Но в отличие от позиционирования, которым можно двигать боксы практически
произвольно, все, что может float — это сдвинуть элемент к одной из сторон
потока, правой или левой. При этом сам бокс и следующие за ним в потоке
приобретают интересное поведение:
  float'нутый бокс смещается по горизонтали и прилипает к одной из сторон
  родителя.

float и ширина [9/32]

Вы уже знаете, что по умолчанию блочные элементы растягиваются на всю доступную
ширину родителя.
Если мы задаём элементу свойство float:left или float:right,
то он прижимается к левому или правому краю, а также начинает ужиматься
по ширине под своё содержимое. С той стороны, которая не прижата к краю родителя,
появляется свободное место. Это место может быть занято другими элементами.
Зафлоаченному элементу можно явно задавать размеры и отступы.
Есть тонкость, связанная со строчными элементами.
Если зафлоатить строчный элемент, то он начинает вести себя как блочный,
а именно: воспринимать размеры и отступы.

float и выпадание из потока [10/32]

Зафлоаченные элементы выпадают из потока, но лишь частично:
Блочные элементы, которые идут в коде после зафлоаченного блока, перестают его
замечать.
Они подтягиваются вверх и занимают его место, как будто его и нет.
Строчные же элементы, расположенные в коде после зафлоаченного блока, начинают
обтекать его со свободной стороны.
Ещё раз: для блочных элементов флоатные не существуют, но текст внутри блоков
флоатные обтекает.
Такое поведение флоатов даёт интересные эффекты:
1.Эффект прохождения сквозь блоки.
  Проявляется, когда зафлоаченный элемент выше, чем несколько последующих за
  ним блоков.
2.Эффект выпадания из родителя или схлопывания родителя.
  Проявляется тогда, когда все дочерние блоки в родителе зафлоачены.
В этом случае родитель схлопывается по высоте, как будто в нём нет содержимого,
а блоки выпадают из него.
Флоатные элементы видят друг друга.
Идущие друг за другом флоаты выстраиваются в ряд, пока им хватает свободного места.
Если места не хватает, то они начинают переноситься на следующую строчку. Почти
как текст.

Когда флоатов много, а места мало [12/32]

Следует отметить, что поведение нескольких флоатов, когда им не хватает места в
одной строке, является очень странным.
Когда не влезающий флоат переносится на новую строку, возможно несколько
вариантов и не все из них логичны. Например, флоат может «зацепиться» за один
из предшествующих флоатов и встать ниже не в самом начале строки, а за
предшествующим.

Свойство clear [14/32]

Свойство clear запрещает обтекание элемента другими элементами.
Вот его значения:
  left — запрещено обтекание слева;
  right — запрещено обтекание справа;
  both — запрещено обтекание с обеих сторон;
  none — обтекание разрешено.
Если после флоатного элемента расположен элемент с запрещённым обтеканием, то
последний опускается под флоатный.
Свойство clear учит блочные элементы «видеть» зафлоаченные.

Борьба с выпаданием флоатов: распорки [15/32]

Эффект выпадания флоатов из родителя был большой проблемой при построении сеток.
Ведь сетки на флоатах обычно делаются вот так:
  1. Создаём блок-контейнер для колонок.
  2. В контейнер добавляем флоатные блоки-колонки.
  3. Рассчитываем ширины колонок так, чтобы им хватало места в родителе.
Такой подход работает неплохо. Но проблемы начинаются тогда, когда у контейнера
есть фон, отличный от фона страницы. Когда колонки выпадали, родитель
схлопывался и фон пропадал.
Необходимо было найти способ борьбы с выпаданием.
Тут и пригодилось свойство clear:both.
Стали применять такую структуру:
<div class="container"> - блок-контейнер
    <div class="column1">...</div> - колонка, флоат
    <div class="column2">...</div> - колонка, флоат
    <div class="clearfix"></div> - распорка с clear:both
</div>
Т. е. начали добавлять после зафлоаченных колонок пустой элемент-распорку со
свойством clear:both. Этот элемент видел колонки, не давал им пройти через себя,
а заодно и растягивал родительский блок по высоте.
Для таких распорок прижилось специальное название класса — clearfix.

Борьба с выпаданием флоатов: псевдораспорки [16/32]

Хорошие верстальщики не очень любят, когда в вёрстке появляются ненужные
дополнительные элементы и стараются от них избавляться.
До поры до времени с блоками-распорками приходилось мириться, т. к. без них
было никак не обойтись.
Но время шло и в браузерах появилась поддержка так называемых псевдоэлементов.
Псевдоэлементы позволяют с помощью CSS вставить в структуру HTML-документа узлы,
которых нет в HTML коде. Т. е. можно вставить в код элемент и не писать его в HTML.
Благодаря псевдоэлементам появилось решение проблемы флоатов без использования
дополнительного элемента.
Назовём это решение псевдораспорками.
Есть несколько его вариаций, но вот одна из распространённых.
В CSS добавляется следующее правило:
.clearfix::after {
    content: "";
    display: table;
    clear: both;
}
А затем класс clearfix добавляется к контейнеру, внутри которого лежат флоатные
колонки. После этого в контейнер не нужно добавлять дополнительный
элемент-распорку, т. к. распорка создаётся с помощью псевдоэлемента.
