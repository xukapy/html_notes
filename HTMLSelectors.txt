Контекстные селекторы [5/18] (space)

Селектор может состоять из нескольких частей, разделённых пробелом, например:
p strong { ... }
ul .hit { ... }
.footer .menu a { ... }
Такие селекторы называют контекстными или вложенными. Их используют для того,
чтобы применить стили к элементу, только если он вложен в нужный элемент.
Уровень вложенности не важен.

Например, селектор [.menu a] сработает для ссылки a только в том случае, если она
расположена внутри элемента с классом .menu.
Читать их проще всего справа налево:
/* выбрать все теги strong внутри тегов p */
p strong { ... }

Соседние селекторы [6/18] (+)

Контекстные селекторы используются для вложенных друг в друга элементов,
а соседние — для расположенных рядом. Например, теги <li> в списке являются
соседними по отношению друг к другу и вложенными в тег <ul>.
Соседние селекторы записываются с помощью знака +
Например: селектор1 + селектор2.
Стили применятся к элементу, подходящему под селектор2, только если
сразу перед ним расположен элемент, подходящий под селектор1.

Пример. Есть два элемента списка:
<li class="hit"></li>
<li class="miss"></li>
Селектор .hit + .miss применит стили к элементу с классом miss,
так как перед ним есть элемент с классом hit.
Селектор .hit + li тоже применит стили к элементу с классом miss,
а селектор .miss + .hit не сработает.


Контекстные и соседние селекторы [7/18]

Селекторы в CSS можно очень гибко комбинировать. В частности, можно
комбинировать контекстные и соседние селекторы.
Например, селектор .player-1 .hit + .miss сработает для тега с классом
miss, если сразу перед ним расположен тег с классом hit и
оба тега расположены внутри тега с классом player-1.

Дочерние селекторы [8/18] (>)

Потомком называются любые элементы, расположенные внутри родительского
элемента. А дочерними элементами называются ближайшие потомки.
Взгляните на пример:
<ul>
  <li><span>...</span></li>
  <li><span>...</span></li>
</ul>
По отношению к <ul> <li> являются дочерними элементами и потомками,
а <span> — потомки, но не дочерние элементы.
Контекстные селекторы влияют на всех потомков, что не всегда удобно.
Иногда необходимо задать стили только для дочерних элементов.
Особенно это полезно при работе с многоуровневыми списками.

Для этого существует дочерний селектор, в котором используется символ >.
Например: ul > li или ul > li > span


Псевдоклассы [9/18]

Псевдоклассы — это дополнения к обычным селекторам, которые делают их
ещё точнее и мощнее.
Псевдокласс добавляется к селектору c помощью символа :, вот так
  селектор:псевдокласс.

Например:
  a:visited { ... }
  li:last-child { ... }
  .alert:hover { ... }

Псевдоклассы first-child, last-child позволяют выбрать первый и
последний дочерние элементы родителя.
Применяется к самому элементу, а не родителю.

Псевдокласс nth-child можно выбирать теги по порядковому номеру,
не используя классы.
Синтаксис псевдокласса: селектор:nth-child(выражение).
Выражением может быть число или формула.
Например:
1. li:nth-child(2) { ... } - второйй элемент
2. li:nth-child(4) { ... } - четвертый
3. li:nth-child(2n) { ... } - четные

Псевдокласс hover позволяет выбрать элемент, когда на него наведён курсор мыши и
кнопка мыши не нажата.
Примеры:
1. a:hover { ... } выбирает ссылку, когда наведен курсор мыши
2 .menu-item:hover { ... }  выбирает элемент с классом menu-item
Благодаря этому псевдоклассу можно добавлять в интерфейс динамику и
интерактивность, так как элементы начинают реагировать на действия
пользователя, изменяя свой внешний вид.

Динамические эффекты с помощью :hover [13/18]

Интересовались ли вы, как с помощью CSS создаются выпадающие меню?
Львиная доля динамических эффектов, создаваемых с помощью CSS,
опираются на несколько псевдоклассов, главный из которых, конечно же, :hover.
Весь секрет заключается в сочетании контекстных селекторов и псевдоклассов.
Посмотрите на пример:
li.top ul.submenu {
  display: none;
}

li.top:hover ul.submenu {
  display: block;
}
Первое правило прячет список-подменю. Второе правило гласит: «если на верхний
пункт меню, в котором находится подменю, наведут курсор, то надо показать
подменю». Вот так всё просто.
Общий принцип такой: родительский элемент реагирует на наведение мыши и изменяет
свойства элементов-потомков. То есть всё работает на контекстных селекторах
вида селектор1:hover селектор2.

Псевдоклассы для ссылок :link, :visited и :active [14/18]

:link выбирает ещё не посещённые ссылки.
:visited выбирает посещённые ссылки.
:active выбирает активные ссылки (кнопка мыши зажата на ссылке).

Пример задания CSS-правил для ссылок:
a:link { ... }
a:visited { ... }
a:hover { ... }
a:active { ... }
Обратите внимание на порядок правил. Если их расположить по-другому,
то некоторые могут не сработать.

Псевдокласс :focus позволяет выбрать элемент, который в данный момент
в фокусе. Например, текстовое поле, в которое установлен курсор,
находится в фокусе.
В фокусе могут быть не только текстовые поля. Если вы переключаетесь
между элементами веб-страницы с помощью клавиши tab, то в фокус будут
попадать ссылки.
Пример:
input:focus {
  /* стили для поля в фокусе */
}

Селекторы атрибутов [16/18] [атрибут], [атрибут="значение"]

Существуют селекторы, которые позволяют выбирать элементы по любым атрибутам.
Чаще всего такие селекторы используются при работе с формами, так как поля форм
имеют атрибут type с разными значениями.
Селекторы атрибутов записываются с использованием квадратных скобок:
  элемент[атрибут].

Примеры селекторов:
1. input[checked] { ... }
2. input[type="text"] { ... }
Первый селектор выберет поля формы, у которых есть атрибут checked, второй
селектор выберет поля формы, у которых атрибут type имеет значение text.


Объединение селекторов [1/20]

Иногда может потребоваться выбрать элементы, которые одновременно
удовлетворяют сразу нескольким условиям.
В CSS есть запись, которая фактически выполняет операцию логического
умножения, «И». Селекторы, применяемые к одному элементу, в этом случае
пишутся без пробелов:
.class1.class2 { }
Стили будут применяться ко всем элементам, которые одновременно имеют
класс class1 и class2.
Например:
<div class="class1 class2">Блок с двумя классами</div>
По такому же принципу можно объединять любое количество абсолютно разных
селекторов. И чем больше селекторов вы объединяете, тем больше условий
должно совпасть для применения стилей.

Псевдокласс :not [2/20]

Псевдокласс :not(селектор) является отрицающим селектором.
С его помощью можно выбрать элементы, которые НЕ содержат указанный
селектор:
li:not(:last-child) { }
Этот селектор выберет все теги <li>, НЕ являющиеся последними в их родителе.
В качестве селектора могут указываться псевдоклассы, теги, идентификаторы,
классы и селекторы атрибутов. Нельзя использовать двойной
псевдокласс :not, то есть конструкция :not(:not(...)) не сработает.
Также в комбинации с :not не применяются:
  1. объединение селекторов: например, li:not(.heart.jack) – некорректный селектор;
  2. псевдоэлементы: li:not(::after) – неправильная запись;
  3. селекторы-потомки, групповые селекторы или комбинации:
     например, нельзя писать li:not(a span) или li:not(a + span).

Комбинируем :not [3/20]

Отрицающий селектор :not, как и любые другие селекторы, можно комбинировать с
другими.
Например:
li:not(:first-child):not(:last-child) { }
Выберет все теги <li>, которые НЕ являются первыми и последними в их
родителе. Объединять можно неограниченное количество селекторов.

Псевдокласс :nth-last-child [4/20]

Псевдокласс :nth-last-child используется для добавления стиля к элементам
на основе нумерации в дереве элементов. В отличие от
псевдокласса :nth-child, отсчет ведется не от первого элемента,
а от последнего.

Псевдокласс :first-of-type, :last-of-type, :nth-of-type, :nth-last-of-type

Псевдокласс :first-of-typeочень похож на :first-child.
Он выбирает первый дочерний элемент родителя, только с учетом
типа элементов.
Например:
<body>
    <div class="paper"> … </div>
    <ul class="cards"> … </ul>
    <ul class="cards"> … </ul>
</body>
Сравним две записи:
ul:first-child {
   background: #ffffee;
}
ul:first-of-type {
   background: #ffffee;
}
Верхний селектор выбирает первый дочерний элемент в родителе,
причем этот элемент должен быть ul. В нашем случае не выберется ничего,
потому что первым дочерним элементом body является div.
Нижний селектор выбирает первый ul среди всех дочерних ul в своем родителе.
В нашем случае будет выбран первая строка с картами
Аналогично  :last-of-type, :nth-of-type, :nth-last-of-type

Cелектор последующих элементов [10/20]

Ранее мы уже рассматривали соседние селекторы, которые записываются
как селектор1 + селектор2.
Есть похожий селектор селектор1 ~ селектор2. Стили применятся к элементу,
подходящему под селектор2, только если перед ним расположен элемент,
подходящий под селектор1.

Отличие от соседнего селектора состоит в том, что между элементами
селектор1 и селектор2 могут находиться другие элементы.
<ul class="cards">
    <li class="king diamond">
    <li class="queen heart">
    <li class="jack spade">
    <li class="ace heart">
    <li class="king club">
</ul>

.queen.heart + li {
   background-color: #ffff99;
}
.king.diamond ~ li {
   background-color: #99ddff;
}
В первом случае выделится одна карта, расположенная сразу за червовой
дамой, то есть пиковый валет.
Во втором случае выделятся все карты, которые стоят за бубновым королем,
то есть червовая дама, пиковый валет, червовый туз и трефовый король.

Псевдокласс :empty [11/20]

Псевдокласс :empty, выбирает только те теги, у которых нет дочерних
элементов (в том числе текстовых узлов). Учтите, что даже переход
на новую строку считается текстовым узлом, помните об этом в процессе
проектирования структуры страницы.

Псевдокласс :only-child, :only-of-type  [12/20]

Псевдокласс :only-child пригодится, когда нужно прописать
индивидуальные стили для элемента, который является единственным
дочерним элементом внутри родительского контейнера.
Пример:
li:only-child {
    ...
}
Сработает, когда этот <li> в списке единственный.
Cелектор :only-child эквивалентен селектору
elem:last-child:first-child.
:only-of-type работает аналогично, но с учетом типа

Псевдоэлементы ::before  ::after[14/20]

Псевдоэлемент before позволяет с помощью CSS добавить псевдотег
внутрь другого элемента и оформить его. Cодержимое псевдотега
задаётся с помощью свойства content.
Например, у нас есть такой HTML:
<div class="queen heart">
    <em>Дама</em>
</div>
Добавим CSS-правило с необычным селектором с двойным двоеточием:
.heart::before { content: "Черви"; }
И HTML изменится вот так:
<div class="queen heart">
    <before>Черви</before>
    <em>Дама</em>
</div>
Но! Исходный HTML-код не изменится, тег <before> не попадёт в код
страницы, а будет «виртуально» существовать где-то в браузере.
Поэтому мы и используем приставку псевдо.
Ведёт себя псевдотег так же, как обычный <span> с текстом.
Ему можно задавать дополнительные стили, например:
.heart::before {
     content: "Черви";
     color: red;
}
Чтобы псевдоэлемент появился, ему необходимо задать свойство content.
Достаточно даже пустой строки в значении свойства — content: "";.
Псевдоэлемент after аналогичен before. Отличие заключается в том,
что он добавляет псевдотег не в начало, а в конец элемента.
Псевдоэлементы before и after можно использовать одновременно.
Это означает, что с помощью CSS вы можете добавить к любому элементу
на странице два псевдоэлемента.

Псевдоэлементы ::first-line и ::first-letter [18/20]

Псевдоэлемент first-line задает стиль первой строки форматированного
текста. Длина этой строки зависит от многих факторов,
таких как используемый шрифт, размер окна браузера, ширина блока,
языка и т.д. В правилах стиля допустимо использовать только свойства,
относящиеся к шрифту, изменению цвета текста и фона.
Пример:
p::first-line { }
Аналогично псевдоэлемент first-letter определяет стиль первого символа
в тексте элемента, к которому добавляется. К этому псевдоэлементу
могут применяться только стилевые свойства, связанные со
свойствами шрифта, полями, отступами, границами, цветом и фоном.
Пример:
p::first-letter { }
